# Wrapper for the HCL Application Security on Cloud SAClient Utility
# Use this to automate the creation of IRX files, Scans in ASoC, and downloading scan results
# Author: Cody Travis
# Email: cody.travis@hcl.com
# Date: 2020-10-06

import sys
import json
import subprocess
import io
import datetime
import os
import time
import platform


class SAClient:
    debug = False
    api_key = None
    platform = None
    appscan_cmd = ""
    persistLogin = None
    
    def __init__(self, asoc_keyid, asoc_keyscret, persistLogin=False, debug=False):
        self.api_key = {
            "keyid": asoc_keyid,
            "keysecret": asoc_keyscret
        }
        self.debug = debug
        self.platform = platform.system()
        if "Windows" in self.platform:
            self.appscan_cmd = "appscan"
        else:
            self.appscan_cmd = "appscan.sh"
        
    # Function: setDebug
    # Description:
    #   Set setdebug to True to print the stdout to
    #   SAClientUtil system calls.
    # Requires:
    #        setdebug - Set to True to print stdout from SAClientUtil
    # Returns:
    #       nothing
    def setDebug(setdebug=False):
        global debug
        debug = setdebug
    
    # Function: loginASoC
    # Description:
    #    Wraps the appscan api_login command
    #     Authenticate to the ASoC Service using API Key
    # Requires:
    #        None - api_key is set by Constructor
    # Optional:
    #        persist - (optional) Set to true if you want the client to attempt
    #                             to reauthenticate when the token expires
    # Returns:
    #        True if login is successful
    #        False if login fails
    def loginASoC(self, persist=False):
        if(persist):
            cmd = [self.appscan_cmd, "api_login", "-u", self.api_key["keyid"], "-P", self.api_key["keysecret"], "-persist"]
        else:
            cmd = [self.appscan_cmd, "api_login", "-u", self.api_key["keyid"], "-P", self.api_key["keysecret"]]
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, err) = p.communicate()
        p_status = p.wait()
        if(self.debug): 
            print(output.decode('ascii'))
        return output.decode('ascii').find("Authenticated successfully")>=0
        
    # Function destroyToken
    # Description:
    #    Removes the cli.token file which is used by SAClient to authenticate to the service
    #    Call this when the automation process is complete to invalidate the session
    #    The default location of this file is %HOME%/.appscan/cli.token
    #    If the HOME env variable is not set, you will need to specify the location manually
    # Optional:
    #        tokenPath - The file path to the cli.token file. Leave blank to use the default location
    # Returns:
    #    True if the file was deleted successfully
    #    False if the file was not deleted or does not exist
    def destroyToken(self, tokenPath=None):
        if(tokenPath is None):
            homeDir = os.getenv("HOME")
            if(homeDir is None):
                return False
            tokenPath = homeDir + "/.appscan/cli.token"
        if(os.path.exists(tokenPath)):
            os.remove(tokenPath)
            return True
        return False

    # Function: generateIRX
    # Description:
    #    Wraps the appscan prepare command
    #    Generates an IRX File configured by the supplied appscan-config.xml file
    # Requires:
    #        scanName - This will be the base name of the scan in ASoC and irx file
    #        configFile - The name or path to a config file that will be used to generate the IRX
    # Returns:
    #        ScanName The name of the IRX file (scan name + a timestamp)
    #        None - if IRX generation is not successful
    def generateIRX(self, scanName, configFile=None):
        scanName = scanName+"_"+self.getTimeStamp()
        stdoutFile = scanName+'_stdout.txt'
        with io.open(stdoutFile, 'wb') as writer, io.open(stdoutFile, 'rb') as reader:
            if(configFile):
                process = subprocess.Popen([self.appscan_cmd, "prepare", "-c", configFile, "-n", scanName], stdout=writer, shell=True)
            else:
                process = subprocess.Popen([self.appscan_cmd, "prepare", "-n", scanName], stdout=writer, shell=True)
            while process.poll() is None:
                sys.stdout.write(reader.read().decode('ascii'))
                time.sleep(0.5)
            sys.stdout.write(str(reader.read().decode('ascii')))
        if(os.path.exists(scanName + ".irx")):
            return scanName
        else:
            return None

    # Function: getReport
    # Description:
    #    Wraps the appscan get_result command
    #     Downloads an html scan report or a zip file that contains all available reports (xml, raw xml, html)
    # Requires:
    #        scanId - The Id of this scan as generated by "queue_analysis"
    #        filePath - The destination file path of the report file
    # Optional:
    #        type - The type of file returned. Possible values are "html" (default) and "zip"
    # Returns:
    #         True - If the report was saved successfully
    #        False - If the report was not saved
    # Exceptions: 
    #        UnauthenticatedException - if not logged in
    #        ScanNotFoundException - if the scanId is not valid
    def getReport(self, scanId, filePath, type="html"):
        p = subprocess.Popen([self.appscan_cmd, "get_result", "-d", filePath, "-i", scanId, "-t", type], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, err) = p.communicate()
        p_status = p.wait()
        if self.isLoggedIn(err.decode()) == False:
            raise UnauthenticatedException()
        if err.decode().find("Invalid UUID")>=0:
            raise ScanNotFoundException()
        return output.decode().find("Results retrieved successfully")>=0

    # Function: getScanSummary
    # Description:
    #    Wraps the appscan info command
    #     Gets the summary of a scan that is in progress or complete
    # Requires:
    #        scanId - The Id of this scan as generated by "queue_analysis"
    # Optional:
    #        fileName - The destination file to save the json response
    # Returns:
    #         The json object that contains the scan summary information or None if something went wrong
    # Exceptions: 
    #        UnauthenticatedException - raised if not logged in
    #        ScanNotFoundException - raised if the scanId is not valid
    def getScanSummary(self, scanId, fileName=None):
        p = subprocess.Popen([self.appscan_cmd, "info", "-i", scanId, "-json"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, err) = p.communicate()
        p_status = p.wait()
        if self.isLoggedIn(err.decode()) == False:
            raise UnauthenticatedException()
        if err.decode().find("Invalid UUID")>=0:
            raise ScanNotFoundException()
        jsonObj = json.loads(output.decode())
        if fileName is not None:
            f = open(fileName, 'w+')
            f.write(json.dumps(jsonObj))
        return jsonObj

    # Function: getScanStatus
    # Description:
    #    Wraps the appscan status command
    #     Gets the status of a scan
    # Requires:
    #        scanId - The Id of this scan as generated by "queue_analysis"
    # Returns:
    #         The status of the scan - possible values are Ready, Running, Failed, or InQueue
    # Exceptions: 
    #        UnauthenticatedException - raised if not logged in
    #        ScanNotFoundException - raised if the scanId is not valid    
    def getScanStatus(self, scanId):
        p = subprocess.Popen([self.appscan_cmd, "status", "-i", scanId], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, err) = p.communicate()
        p_status = p.wait()
        if self.isLoggedIn(err.decode()) == False:
            raise UnauthenticatedException()
        if err.decode().find("Invalid UUID")>=0:
            raise ScanNotFoundException()
        status = output.decode()
        if (status == "Running") or (status == "Ready") or (status == "Failed") or (status == "InQueue"):
            return status
        else:
            return None
            
    # Function: getAppList
    # Description:
    #    Wraps the appscan list_apps command
    #     Gets a list of application names and Id's associated with the ASoC Account
    # Returns:
    #         A Dictionary object of the format appList["appname"] = appId
    # Exceptions: 
    #        UnauthenticatedException - if not logged in
    def getAppList(self):
        appList = {}
        p = subprocess.Popen([self.appscan_cmd, "list_apps"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, err) = p.communicate()
        p_status = p.wait()
        if self.isLoggedIn(err.decode()) == False:
            raise UnauthenticatedException()
        if self.debug:
            print(output.decode())
            
        lines = output.decode().split('\n')
        for line in lines:
            temp = line.split(' [ ')
            if len(temp)<2:
                continue
            #appList[temp[0]] = temp[1].split(' ]')[0]
            appList[temp[1].split(' ]')[0]] = temp[0]
        return appList
    
    # Function: findSingleApp
    # Description:
    #    Finds a single app based on the provided appId or name.
    # Returns:
    #         A Dictionary object of the format {"name"="<NAME>", "id"="<APPID>"}
    def findSingleApp(self, nameOrId):
        apps = {}
        app = {
            "name": None,
            "id": None
        }
        try:
            apps = self.getAppList()
            #Check if ID is provided and found
            if nameOrId in apps.keys():
                app["name"] = apps[nameOrId]
                app["id"] = nameOrId
                return app
            #Check if Name is provided and found
            if nameOrId in apps.values():
                for a in apps:
                    if apps[a] == nameOrId:
                        app["name"] = nameOrId
                        app["id"] = a
                        return app
            if self.debug:
                print("App with name or id {" + str(nameOrId) + "} not found.")
            return None
        except UnauthenticatedException:
            if self.debug:
                print("Unauthenticated Exception. Please login first or renew login session")
            return None
            
    # Function: queueAnalysis
    # Description:
    #    Wraps the appscan queue_analysis command
    #     Uploads an IRX file for analysis
    # Requires:
    #        irxFile - The path to the IRX file to be scanned
    #        scanName - The name of the scan to be created
    #        appId - The application Id to associate the scan results with
    # Returns:
    #         The scanId of the scan that was created, or None if something went wrong
    # Exceptions: 
    #        UnauthenticatedException - if not logged in
    #        ApplicationNotFoundExceptionException - if the appId is not valid or user does not have permission to access it
    def queueAnalysis(self, irxFile, scanName, appId):
        p = subprocess.Popen([self.appscan_cmd, "queue_analysis", "-f", irxFile, "-n", scanName, "-a", appId], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (output, err) = p.communicate()
        p_status = p.wait()
        if self.isLoggedIn(err.decode()) == False:
            raise UnauthenticatedException()
        if err.decode().find("Could not associate scan with application")>=0:
            raise ApplicationNotFoundExceptionException()
        lines = output.decode().split('\n')
        if self.debug:
            print(output.decode())
            print(err.decode())
            
        if len(lines[-1]) > 0:
            return lines[-1]
        return None
        
    # Function: waitForScan
    # Description:
    #    Waits for a scan to reach a target status
    #     Or until the timeout has been exceeded
    # Requires:
    #        scanId - The scanId of the scan to monitor
    # Optional:
    #        timeoutMins - The amount of minutes to wait for the scan to reach target status before giving update (default 90)
    #        targetStatus - The target Status waiting for the scan to reach (default "Ready")
    # Returns:
    #         last known scan status or "timeout" if the timeout was reached
    # Exceptions: 
    #        UnauthenticatedException - if not logged in
    #        ScanNotFoundException - if the scanId is not valid or user does not have permission to access it
    def waitForScan(self, scanId, timeoutMins=360, targetStatus="Ready", printStatusEveryMins=5):
        try:
            curStatus = self.getScanStatus(scanId)
        except UnauthenticatedException:
            if self.loginASoC()==False:
                raise UnauthenticatedException
            curStatus = self.getScanStatus(scanId)

        minsWaited = 0
        while curStatus != targetStatus:
            if curStatus == "Failed":
                break
            time.sleep(60) #Sleep 1 min
            minsWaited += 1
            if minsWaited >= timeoutMins:
                return "Timeout"
            curStatus = self.getScanStatus(scanId)
            if (printStatusEveryMins > 0) and (minsWaited % printStatusEveryMins == 0):
                try:
                    curStatus = self.getScanStatus(scanId)
                    summary = self.getScanSummary(scanId)
                except UnauthenticatedException:
                    print("UnauthenticatedException: Session to ASoC has expired.")
                    if self.loginASoC()==False:
                        print("Could not reauthenticate. Exiting")
                        sys.exit(1)
                    curStatus = self.getScanStatus(scanId)
                    summary = self.getScanSummary(scanId)
                print("Current Status: " + curStatus + "  Progress: " + str(summary["LatestExecution"]["Progress"]) + "%")
        return curStatus

    #Returns False if the response string contains messages about not being logged in    
    def isLoggedIn(self, response):
        if response.find("You must be authenticated")>=0:
            return False
        if response.find("The token has expired")>=0:
            return False
        return True
    
    #Get current system timestamp
    def getTimeStamp(self):
        ts = time.time()
        return datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d_%H-%M-%S')
        
    #Determine if a text file contains the target string    
    def fileContains(self, fileName, targetStr):
        result = False
        f = open(fileName, 'r')
        for line in f:
            if line.find(targetStr) >= 0:
                result = True
                break
        f.close()
        return result

    #Helper Function to Format a time delta obj
    def strfdelta(self, tdelta, fmt):
        d = {"days": tdelta.days}
        d["hours"], rem = divmod(tdelta.seconds, 3600)
        d["minutes"], d["seconds"] = divmod(rem, 60)
        return fmt.format(**d)
    
    def test(self):
        raise UnauthenticatedException
        
#Exception raised if an api returns an authentication error(not logged in)
class UnauthenticatedException(Exception):
    message = None
    def __init__(self):
        self.message = "You are not logged into AppScan on Cloud"
        Exception.__init__(self,self.message) 

#Exception raised if an api call that requires a scan id, but is given an invalid scanId
class ScanNotFoundException(Exception):
    def __init__(self):
        Exception.__init__(self,"Scan Id was not found in AppScan on Cloud, or you do not have permission to access it.") 

#Exception raised if an api call that requires a app id, but is given an invalid appId        
class ApplicationNotFoundExceptionException(Exception):
    def __init__(self):
        Exception.__init__(self,"Application Id could not be found or you do not have permission to access it.") 

#Copyright 2020 Cody Travis

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#  http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.